ca65 V2.18 - N/A
Main file   : ./src/BIOS.asm
Current file: ./src/BIOS.asm

000000r 1               .include "../include/6502.inc"
000000r 2               .setcpu "65C02"
000000r 2               
000000r 2               .segment "ZEROPAGE"
000000r 2  xx           READ_PTR:     .res 1
000001r 2  xx           WRITE_PTR:    .res 1
000002r 2               
000002r 2               .segment "STACK"
000000r 2  xx xx xx xx  STACK: .res $100
000004r 2  xx xx xx xx  
000008r 2  xx xx xx xx  
000100r 2               
000100r 2               .segment "INPUT_BUFFER"
000000r 2  xx xx xx xx  INPUT_BUFFER: .res $100
000004r 2  xx xx xx xx  
000008r 2  xx xx xx xx  
000100r 2               
000100r 2               .segment "KERNAL_VARS"
000000r 2               
000000r 2               ; LCD Card | $8000-$800F
000000r 2               LCD_PORTB       = $8000
000000r 2               LCD_PORTA       = $8001
000000r 2               LCD_DDRB        = $8002
000000r 2               LCD_DDRA        = $8003
000000r 2               LCD_T1CL        = $8004
000000r 2               LCD_T1CH        = $8005
000000r 2               LCD_T1LL        = $8006
000000r 2               LCD_T1LH        = $8007
000000r 2               LCD_T2CL        = $8008
000000r 2               LCD_T2CH        = $8009
000000r 2               LCD_SR          = $800A
000000r 2               LCD_ACR         = $800B
000000r 2               LCD_PCR         = $800C
000000r 2               LCD_IFR         = $800D
000000r 2               LCD_IER         = $800E
000000r 2               LCD_ORA         = $800F
000000r 2               
000000r 2               LCD_E           = %10000000
000000r 2               LCD_RW          = %01000000
000000r 2               LCD_RS          = %00100000
000000r 2               
000000r 2               ; RAM Card | $8000-$87FF
000000r 2               RAM_DATA_L      = $8000     ; R/W ($8000-$83FE)
000000r 2               RAM_DATA_H      = $8400     ; R/W ($8400-$87FE)
000000r 2               RAM_BANK        = $83FF     ; All three RAM_BANK addresses address the same bank
000000r 2               RAM_BANK_L      = $83FF     ; latch and can be univerally interchanged
000000r 2               RAM_BANK_H      = $87FF     ; RAM bank latch value ($00-$FF) sets which of 256 ~1K banks of RAM is selected in both H or L
000000r 2               
000000r 2               ; Emulator | $8400-$8411
000000r 2               EMU_DATA        = $8400     ; Write
000000r 2               EMU_SCRATCH     = $8401     ; R/W   (Devboard 0 only)
000000r 2               EMU_GPIO_DATA   = $8402     ; R/W   (Devboard 0 only)
000000r 2               EMU_GPIO_DDR    = $8403     ; R/W   (Devboard 0 only)
000000r 2               EMU_SPI_TRANS   = $8401     ; R/W   (Devboard 1 only)
000000r 2               EMU_SPI_CTRL    = $8402     ; Write (Devboard 1 only)
000000r 2               EMU_SPI_STATUS  = $8402     ; Read  (Devboard 1 only)
000000r 2               EMU_SPI_CLK     = $8403     ; R/W   (Devboard 1 only)
000000r 2               EMU_KB_DATA     = $8404     ; Read
000000r 2               EMU_MOUSE_X     = $8405     ; Read
000000r 2               EMU_MOUSE_Y     = $8406     ; Read
000000r 2               EMU_MOUSE_W     = $8407     ; Read
000000r 2               EMU_MOUSE_BTNS  = $8408     ; Read
000000r 2               EMU_JOY_BTNS    = $8409     ; Read
000000r 2               EMU_JOY_BTNS_L  = $840A     ; Read
000000r 2               EMU_JOY_BTNS_H  = $840B     ; Read
000000r 2               EMU_RTC_SEC     = $840C     ; Read
000000r 2               EMU_RTC_MIN     = $840D     ; Read
000000r 2               EMU_RTC_HR      = $840E     ; Read
000000r 2               EMU_RTC_DAY     = $840F     ; Read
000000r 2               EMU_RTC_MON     = $8410     ; Read
000000r 2               EMU_RTC_YR      = $8411     ; Read
000000r 2               
000000r 2               ; RTC Card | $8800-$881F
000000r 2               RTC_SEC         = $8800
000000r 2               RTC_MIN         = $8801
000000r 2               RTC_HR          = $8802
000000r 2               RTC_DAY         = $8803
000000r 2               RTC_DATE        = $8804
000000r 2               RTC_MON         = $8805
000000r 2               RTC_YR          = $8806
000000r 2               RTC_CENT        = $8807
000000r 2               RTC_ALARM_SEC   = $8808
000000r 2               RTC_ALARM_MIN   = $8809
000000r 2               RTC_ALARM_HR    = $880A
000000r 2               RTC_ALARM_DATE  = $880B
000000r 2               RTC_WD_L        = $880C
000000r 2               RTC_WD_H        = $880D
000000r 2               RTC_CTRL_A      = $880E
000000r 2               RTC_CRTL_B      = $880F
000000r 2               RTC_RAM_ADDR    = $8810
000000r 2               RTC_RAM_DATA    = $8813
000000r 2               
000000r 2               ; Storage Card | $8C00-$8C07
000000r 2               ST_DATA         = $8C00     ; R/W
000000r 2               ST_ERROR        = $8C01     ; Read
000000r 2               ST_FEATURE      = $8C01     ; Write
000000r 2               ST_SECT_CNT     = $8C02     ; R/W
000000r 2               ST_LBA_0        = $8C03     ; R/W
000000r 2               ST_LBA_1        = $8C04     ; R/W
000000r 2               ST_LBA_2        = $8C05     ; R/W
000000r 2               ST_LBA_3        = $8C06     ; R/W
000000r 2               ST_STATUS       = $8C07     ; Read
000000r 2               ST_CMD          = $8C07     ; Write
000000r 2               
000000r 2               ST_ERR_AMNF     = %00000001
000000r 2               ST_ERR_ABRT     = %00000100
000000r 2               ST_ERR_IDNF     = %00010000
000000r 2               ST_ERR_UNC      = %01000000
000000r 2               ST_ERR_BBK      = %10000000
000000r 2               ST_STATUS_ERR   = %00000001
000000r 2               ST_STATUS_IDX   = %00000010
000000r 2               ST_STATUS_CORR  = %00000100
000000r 2               ST_STATUS_DRQ   = %00001000
000000r 2               ST_STATUS_DSC   = %00010000
000000r 2               ST_STATUS_DWF   = %00100000
000000r 2               ST_STATUS_RDY   = %01000000
000000r 2               ST_STATUS_BSY   = %10000000
000000r 2               
000000r 2               ; Serial Card | $9000-$9003
000000r 2               SC_DATA         = $9000     ; R/W
000000r 2               SC_RESET        = $9001     ; Write
000000r 2               SC_STATUS       = $9001     ; Read
000000r 2               SC_CMD          = $9002     ; R/W
000000r 2               SC_CTRL         = $9003     ; R/W
000000r 2               
000000r 2               ; GPIO Card | $9400-$940F
000000r 2               GPIO_PORTB      = $9400
000000r 2               GPIO_PORTA      = $9401
000000r 2               GPIO_DDRB       = $9402
000000r 2               GPIO_DDRA       = $9403
000000r 2               GPIO_T1CL       = $9404
000000r 2               GPIO_T1CH       = $9405
000000r 2               GPIO_T1LL       = $9406
000000r 2               GPIO_T1LH       = $9407
000000r 2               GPIO_T2CL       = $9408
000000r 2               GPIO_T2CH       = $9409
000000r 2               GPIO_SR         = $940A
000000r 2               GPIO_ACR        = $940B
000000r 2               GPIO_PCR        = $940C
000000r 2               GPIO_IFR        = $940D
000000r 2               GPIO_IER        = $940E
000000r 2               GPIO_ORA        = $940F
000000r 2               
000000r 2               ; Sound Card | $9800-$980F
000000r 2               SND_PORTB       = $9400
000000r 2               SND_PORTA       = $9401
000000r 2               SND_DDRB        = $9402
000000r 2               SND_DDRA        = $9403
000000r 2               SND_T1CL        = $9404
000000r 2               SND_T1CH        = $9405
000000r 2               SND_T1LL        = $9406
000000r 2               SND_T1LH        = $9407
000000r 2               SND_T2CL        = $9408
000000r 2               SND_T2CH        = $9409
000000r 2               SND_SR          = $940A
000000r 2               SND_ACR         = $940B
000000r 2               SND_PCR         = $940C
000000r 2               SND_IFR         = $940D
000000r 2               SND_IER         = $940E
000000r 2               SND_ORA         = $940F
000000r 2               
000000r 2               SND_BC1H        = %11100000   ; SND_PCR CA2
000000r 2               SND_BC1L        = %11000000   ; SND_PCR CA2
000000r 2               SND_BDIRH       = %00001110   ; SND_PCR CB2
000000r 2               SND_BDIRL       = %00001100   ; SND_PCR CB2
000000r 2               
000000r 2               ; Video Card | $9C00-$9C01
000000r 2               VC_DATA         = $9C00       ; R/W
000000r 2               VC_REG          = $9C01       ; Write
000000r 2               VC_STATUS       = $9C01       ; Read
000000r 2               
000000r 1               
000000r 1               .segment "KERNAL"
000000r 1               .include "Wozmon.asm"
000000r 2               XAML  = $24              ; Last "opened" location Low
000000r 2               XAMH  = $25              ; Last "opened" location High
000000r 2               STL   = $26              ; Store address Low
000000r 2               STH   = $27              ; Store address High
000000r 2               L     = $28              ; Hex value parsing Low
000000r 2               H     = $29              ; Hex value parsing High
000000r 2               YSAV  = $2A              ; Used to see if hex value is given
000000r 2               MODE  = $2B              ; $00=XAM, $7F=STOR, $AE=BLOCK XAM
000000r 2               
000000r 2               IN    = INPUT_BUFFER     ; Input buffer
000000r 2               
000000r 2               woz:
000000r 2  A9 10          lda     #$10           ; 8-N-1, 115200 baud.
000002r 2  8D 03 90       sta     SC_CTRL
000005r 2  A0 8B          ldy     #$8B           ; No parity, no echo, no interrupts.
000007r 2  8C 02 90       sty     SC_CMD
00000Ar 2  A9 1B          lda     #$1B           ; Begin with escape.
00000Cr 2               
00000Cr 2               notcr:
00000Cr 2  C9 08          cmp     #$08           ; Backspace key?
00000Er 2  F0 13          beq     backspace      ; Yes.
000010r 2  C9 1B          cmp     #$1B           ; ESC?
000012r 2  F0 03          beq     escape         ; Yes.
000014r 2  C8             iny                    ; Advance text index.
000015r 2  10 0F          bpl     nextchar       ; Auto ESC if line longer than 127.
000017r 2               
000017r 2               escape:
000017r 2  A9 5C          lda     #$5C           ; "\".
000019r 2  20 rr rr       jsr     echo           ; Output it.
00001Cr 2               
00001Cr 2               getline:
00001Cr 2  A9 0D          lda     #$0D           ; Send CR
00001Er 2  20 rr rr       jsr     echo
000021r 2               
000021r 2  A0 01          ldy     #$01           ; Initialize text index.
000023r 2               backspace:
000023r 2  88             dey                    ; Back up text index.
000024r 2  30 F6          bmi     getline        ; Beyond start of line, reinitialize.
000026r 2               
000026r 2               nextchar:
000026r 2  AD 01 90       lda     SC_STATUS      ; Check status.
000029r 2  29 08          and     #$08           ; Key ready?
00002Br 2  F0 F9          beq     nextchar       ; Loop until ready.
00002Dr 2  AD 00 90       lda     SC_DATA        ; Load character. B7 will be '0'.
000030r 2  99 rr rr       sta     IN,Y           ; Add to text buffer.
000033r 2  20 rr rr       jsr     echo           ; Display character.
000036r 2  C9 0D          cmp     #$0D           ; CR?
000038r 2  D0 D2          bne     notcr          ; No.
00003Ar 2               
00003Ar 2  A0 FF          ldy     #$FF           ; Reset text index.
00003Cr 2  A9 00          lda     #$00           ; For XAM mode.
00003Er 2  AA             tax                    ; X=0.
00003Fr 2               setblock:
00003Fr 2  0A             asl
000040r 2               setstor:
000040r 2  0A             asl                    ; Leaves $7B if setting STOR mode.
000041r 2  85 2B          sta     MODE           ; $00 = XAM, $74 = STOR, $B8 = BLOK XAM.
000043r 2               blskip:
000043r 2  C8             iny                    ; Advance text index.
000044r 2               nextitem:
000044r 2  B9 rr rr       lda     IN,Y           ; Get character.
000047r 2  C9 0D          cmp     #$0D           ; CR?
000049r 2  F0 D1          beq     getline        ; Yes, done this line.
00004Br 2  C9 2E          cmp     #$2E           ; "."?
00004Dr 2  90 F4          bcc     blskip         ; Skip delimiter.
00004Fr 2  F0 EE          beq     setblock       ; Set BLOCK XAM mode.
000051r 2  C9 3A          cmp     #$3A           ; ":"?
000053r 2  F0 EB          beq     setstor        ; Yes, set STOR mode.
000055r 2  C9 52          cmp     #$52           ; "R"?
000057r 2  F0 3B          beq     run            ; Yes, run user program.
000059r 2  86 28          stx     L              ; $00 -> L.
00005Br 2  86 29          stx     H              ;    and H.
00005Dr 2  84 2A          sty     YSAV           ; Save Y for comparison
00005Fr 2               
00005Fr 2               nexthex:
00005Fr 2  B9 rr rr       lda     IN,Y           ; Get character for hex test.
000062r 2  49 30          eor     #$30           ; Map digits to $0-9.
000064r 2  C9 0A          cmp     #$0A           ; Digit?
000066r 2  90 06          bcc     dig            ; Yes.
000068r 2  69 88          ADC     #$88           ; Map letter "A"-"F" to $FA-FF.
00006Ar 2  C9 FA          cmp     #$FA           ; Hex letter?
00006Cr 2  90 11          bcc     nothex         ; No, character not hex.
00006Er 2               dig:
00006Er 2  0A             asl
00006Fr 2  0A             asl                    ; Hex digit to MSD of A.
000070r 2  0A             asl
000071r 2  0A             asl
000072r 2               
000072r 2  A2 04          ldx     #$04           ; Shift count.
000074r 2               hexshift:
000074r 2  0A             asl                    ; Hex digit left, MSB to carry.
000075r 2  26 28          rol     L              ; Rotate into LSD.
000077r 2  26 29          rol     H              ; Rotate into MSD's.
000079r 2  CA             dex                    ; Done 4 shifts?
00007Ar 2  D0 F8          bne     hexshift       ; No, loop.
00007Cr 2  C8             iny                    ; Advance text index.
00007Dr 2  D0 E0          bne     nexthex        ; Always taken. Check next character for hex.
00007Fr 2               
00007Fr 2               nothex:
00007Fr 2  C4 2A          cpy     YSAV           ; Check if L, H empty (no hex digits).
000081r 2  F0 94          beq     escape         ; Yes, generate ESC sequence.
000083r 2               
000083r 2  24 2B          bit     MODE           ; Test MODE byte.
000085r 2  50 10          bvc     notstor        ; B6=0 is STOR, 1 is XAM and BLOCK XAM.
000087r 2               
000087r 2  A5 28          lda     L              ; LSD's of hex data.
000089r 2  81 26          sta     (STL,X)        ; Store current 'store index'.
00008Br 2  E6 26          inc     STL            ; Increment store index.
00008Dr 2  D0 B5          bne     nextitem       ; Get next item (no carry).
00008Fr 2  E6 27          inc     STH            ; Add carry to 'store index' high order.
000091r 2               tonextitem:
000091r 2  4C rr rr       jmp     nextitem       ; Get next command item.
000094r 2               
000094r 2               run:
000094r 2  6C 24 00       jmp     (XAML)         ; Run at current XAM index.
000097r 2               
000097r 2               notstor:
000097r 2  30 2B          bmi     xamnext        ; B7 = 0 for XAM, 1 for BLOCK XAM.
000099r 2               
000099r 2  A2 02          ldx     #$02           ; Byte count.
00009Br 2               setadr:
00009Br 2  B5 27          lda     L-1,X          ; Copy hex data to
00009Dr 2  95 25          sta     STL-1,X        ;  'store index'.
00009Fr 2  95 23          sta     XAML-1,X       ; And to 'XAM index'.
0000A1r 2  CA             dex                    ; Next of 2 bytes.
0000A2r 2  D0 F7          bne     setadr         ; Loop unless X = 0.
0000A4r 2               
0000A4r 2               nxtprnt:
0000A4r 2  D0 14          bne     prdata         ; NE means no address to print.
0000A6r 2  A9 0D          lda     #$0D           ; CR.
0000A8r 2  20 rr rr       jsr     echo           ; Output it.
0000ABr 2  A5 25          lda     XAMH           ; 'Examine index' high-order byte.
0000ADr 2  20 rr rr       jsr     prbyte         ; Output it in hex format.
0000B0r 2  A5 24          lda     XAML           ; Low-order 'examine index' byte.
0000B2r 2  20 rr rr       jsr     prbyte         ; Output it in hex format.
0000B5r 2  A9 3A          lda     #$3A           ; ":".
0000B7r 2  20 rr rr       jsr     echo           ; Output it.
0000BAr 2               
0000BAr 2               prdata:
0000BAr 2  A9 20          lda     #$20           ; Blank.
0000BCr 2  20 rr rr       jsr     echo           ; Output it.
0000BFr 2  A1 24          lda     (XAML,X)       ; Get data byte at 'examine index'.
0000C1r 2  20 rr rr       jsr     prbyte         ; Output it in hex format.
0000C4r 2               xamnext:
0000C4r 2  86 2B          stx     MODE           ; 0 -> MODE (XAM mode).
0000C6r 2  A5 24          lda     XAML
0000C8r 2  C5 28          cmp     L              ; Compare 'examine index' to hex data.
0000CAr 2  A5 25          lda     XAMH
0000CCr 2  E5 29          sbc     H
0000CEr 2  B0 C1          bcs     tonextitem     ; Not less, so no more data to output.
0000D0r 2               
0000D0r 2  E6 24          inc     XAML
0000D2r 2  D0 02          bne     mod8chk        ; Increment 'examine index'.
0000D4r 2  E6 25          inc     XAMH
0000D6r 2               
0000D6r 2               mod8chk:
0000D6r 2  A5 24          lda     XAML           ; Check low-order 'examine index' byte
0000D8r 2  29 07          and     #$07           ; For MOD 8 = 0
0000DAr 2  10 C8          bpl     nxtprnt        ; Always taken.
0000DCr 2               
0000DCr 2               prbyte:
0000DCr 2  48             pha                    ; Save A for LSD.
0000DDr 2  4A             lsr
0000DEr 2  4A             lsr
0000DFr 2  4A             lsr                    ; MSD to LSD position.
0000E0r 2  4A             lsr
0000E1r 2  20 rr rr       jsr     prhex          ; Output hex digit.
0000E4r 2  68             pla                    ; Restore A.
0000E5r 2               
0000E5r 2               prhex:
0000E5r 2  29 0F          and     #$0F           ; Mask LSD for hex print.
0000E7r 2  09 30          ora     #$30           ; Add "0".
0000E9r 2  C9 3A          cmp     #$3A           ; Digit?
0000EBr 2  90 02          bcc     echo           ; Yes, output it.
0000EDr 2  69 06          adc     #$06           ; Add offset for letter.
0000EFr 2               
0000EFr 2               echo:
0000EFr 2  48             pha
0000F0r 2  8D 00 90       sta     SC_DATA        ; Output character.
0000F3r 2  A9 FF          lda     #$FF           ; Wait for transmit to complete.
0000F5r 2               txdelay:
0000F5r 2  3A             DEC                    ; Decrement A.
0000F6r 2  D0 FD          bne     txdelay        ; Until A gets to 0.
0000F8r 2  68             pla                    ; Restore A.
0000F9r 2  60             rts                    ; Return.
0000FAr 2               
0000FAr 1  xx xx xx xx  .align 256
0000FEr 1  xx xx        
000100r 1               .include "Kernal.asm"
000100r 2               reset:
000100r 2  4C rr rr       jmp reset
000103r 2               
000103r 2               nmi:
000103r 2               irq:
000103r 2  40             rti
000104r 2               
000104r 1               
000104r 1               .segment "CODE"
000000r 1               
000000r 1               .segment "VECTORS"
000000r 1  rr rr        .word   nmi           ; NMI vector
000002r 1  rr rr        .word   reset         ; RESET vector
000004r 1  rr rr        .word   irq           ; IRQ vector
000004r 1               
