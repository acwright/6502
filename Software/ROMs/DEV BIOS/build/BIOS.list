ca65 V2.18 - N/A
Main file   : ./src/BIOS.asm
Current file: ./src/BIOS.asm

000000r 1               ; ***             ***
000000r 1               ; ***   DB BIOS   ***
000000r 1               ; ***             ***
000000r 1               
000000r 1               .setcpu "65C02"
000000r 1               
000000r 1               .include "../../../6502.inc"
000000r 2               ; ***                     ***
000000r 2               ; ***   6502 INCLUDES     ***
000000r 2               ; ***                     ***
000000r 2               
000000r 2               ; Zero Page
000000r 2               ZP                  := $00
000000r 2               READ_PTR            := $00
000000r 2               WRITE_PTR           := $01
000000r 2               
000000r 2               ; Stack
000000r 2               STACK               := $0100             ; $0100-$01FF
000000r 2               
000000r 2               ; Input Buffer
000000r 2               INPUT_BUFFER        := $0200             ; $0200-$02FF
000000r 2               
000000r 2               ; Kernal Vars
000000r 2               KERNAL_VARS         := $0300             ; $0300-$03FF
000000r 2               
000000r 2               IRQ_PTR             := $0314             ; $0314-$0315
000000r 2               BRK_PTR             := $0316             ; $0316-$0317
000000r 2               NMI_PTR             := $0318             ; $0318-$0319
000000r 2               
000000r 2               ; User Vars
000000r 2               USER_VARS           := $0400             ; $0400-$07FF
000000r 2               
000000r 2               ; Program
000000r 2               PROGRAM             := $0800             ; $0800-$7FFF
000000r 2               
000000r 2               ; RAM Card | IO 1 & 2 | $8000-$87FF
000000r 2               RAM_DATA            := $8000             ; R/W ($8000-$83FE)
000000r 2               RAM_DATA_L          := $8000             ; R/W ($8000-$83FE)
000000r 2               RAM_DATA_H          := $8400             ; R/W ($8400-$87FE)
000000r 2               RAM_BANK            := $83FF             ; All three RAM_BANK addresses address the same bank switching
000000r 2               RAM_BANK_L          := $83FF             ; latch and can be univerally interchanged
000000r 2               RAM_BANK_H          := $87FF             ; RAM bank latch value ($00-$FF) sets which of 256 ~1K banks of RAM is selected in both H or L
000000r 2               
000000r 2               ; Emulator | IO 2 | $8400-$840F
000000r 2               EMU_SER_DATA        := $8400             ; R/W
000000r 2               EMU_SER_CTRL        := $8401             ; Write
000000r 2               EMU_SER_STATUS      := $8401             ; Read
000000r 2               EMU_KB_CMD          := $8402             ; Write
000000r 2               EMU_KB_DATA         := $8402             ; Read
000000r 2               EMU_MOUSE_X         := $8403             ; Read
000000r 2               EMU_MOUSE_Y         := $8404             ; Read
000000r 2               EMU_MOUSE_W         := $8405             ; Read
000000r 2               EMU_MOUSE_BTNS      := $8406             ; Read
000000r 2               EMU_JOY_BTNS        := $8407             ; Read
000000r 2               EMU_RTC_SEC         := $8408             ; Read
000000r 2               EMU_RTC_MIN         := $8409             ; Read
000000r 2               EMU_RTC_HR          := $840A             ; Read
000000r 2               EMU_RTC_DAY         := $840B             ; Read
000000r 2               EMU_RTC_MON         := $840C             ; Read
000000r 2               EMU_RTC_YR          := $840D             ; Read
000000r 2               EMU_PRAM_DATA       := $840E             ; R/W
000000r 2               EMU_PRAM_ADDR       := $840F             ; R/W
000000r 2               EMU_RAM             := $8600             ; R/W
000000r 2               EMU_RAM_BANK        := $87FF             ; Write
000000r 2               
000000r 2               ; RTC Card | IO 3 | $8800-$881F
000000r 2               RTC_SEC             := $8800
000000r 2               RTC_MIN             := $8801
000000r 2               RTC_HR              := $8802
000000r 2               RTC_DAY             := $8803
000000r 2               RTC_DATE            := $8804
000000r 2               RTC_MON             := $8805
000000r 2               RTC_YR              := $8806
000000r 2               RTC_CENT            := $8807
000000r 2               RTC_ALARM_SEC       := $8808
000000r 2               RTC_ALARM_MIN       := $8809
000000r 2               RTC_ALARM_HR        := $880A
000000r 2               RTC_ALARM_DATE      := $880B
000000r 2               RTC_WD_L            := $880C
000000r 2               RTC_WD_H            := $880D
000000r 2               RTC_CTRL_A          := $880E
000000r 2               RTC_CTRL_B          := $880F
000000r 2               RTC_RAM_ADDR        := $8810
000000r 2               RTC_RAM_DATA        := $8813
000000r 2               
000000r 2               ; Storage Card | IO 4 | $8C00-$8C07
000000r 2               ST_DATA             := $8C00             ; R/W
000000r 2               ST_ERROR            := $8C01             ; Read
000000r 2               ST_FEATURE          := $8C01             ; Write
000000r 2               ST_SECT_CNT         := $8C02             ; R/W
000000r 2               ST_LBA_0            := $8C03             ; R/W
000000r 2               ST_LBA_1            := $8C04             ; R/W
000000r 2               ST_LBA_2            := $8C05             ; R/W
000000r 2               ST_LBA_3            := $8C06             ; R/W
000000r 2               ST_STATUS           := $8C07             ; Read
000000r 2               ST_CMD              := $8C07             ; Write
000000r 2               ST_ERR_AMNF         := %00000001
000000r 2               ST_ERR_ABRT         := %00000100
000000r 2               ST_ERR_IDNF         := %00010000
000000r 2               ST_ERR_UNC          := %01000000
000000r 2               ST_ERR_BBK          := %10000000
000000r 2               ST_STATUS_ERR       := %00000001
000000r 2               ST_STATUS_IDX       := %00000010
000000r 2               ST_STATUS_CORR      := %00000100
000000r 2               ST_STATUS_DRQ       := %00001000
000000r 2               ST_STATUS_DSC       := %00010000
000000r 2               ST_STATUS_DWF       := %00100000
000000r 2               ST_STATUS_RDY       := %01000000
000000r 2               ST_STATUS_BSY       := %10000000
000000r 2               
000000r 2               ; Serial Card | IO 5 | $9000-$9003
000000r 2               SC_DATA             := $9000             ; R/W
000000r 2               SC_RESET            := $9001             ; Write
000000r 2               SC_STATUS           := $9001             ; Read
000000r 2               SC_CMD              := $9002             ; R/W
000000r 2               SC_CTRL             := $9003             ; R/W
000000r 2               
000000r 2               ; GPIO Card / Input Board | IO 6 | $9400-$940F
000000r 2               GPIO_PORTB          := $9400
000000r 2               GPIO_PORTA          := $9401
000000r 2               GPIO_DDRB           := $9402
000000r 2               GPIO_DDRA           := $9403
000000r 2               GPIO_T1CL           := $9404
000000r 2               GPIO_T1CH           := $9405
000000r 2               GPIO_T1LL           := $9406
000000r 2               GPIO_T1LH           := $9407
000000r 2               GPIO_T2CL           := $9408
000000r 2               GPIO_T2CH           := $9409
000000r 2               GPIO_SR             := $940A
000000r 2               GPIO_ACR            := $940B
000000r 2               GPIO_PCR            := $940C
000000r 2               GPIO_IFR            := $940D
000000r 2               GPIO_IER            := $940E
000000r 2               GPIO_ORA            := $940F
000000r 2               
000000r 2               ; Sound Card (SID/ARMSID) | IO 7 | $9800-$980F
000000r 2               
000000r 2               
000000r 2               ; Sound Card (AY-3-8912) | IO 7 | $9800-$980F
000000r 2               AY_PORTB            := $9800
000000r 2               AY_PORTA            := $9801
000000r 2               AY_DDRB             := $9802
000000r 2               AY_DDRA             := $9803
000000r 2               AY_T1CL             := $9804
000000r 2               AY_T1CH             := $9805
000000r 2               AY_T1LL             := $9806
000000r 2               AY_T1LH             := $9807
000000r 2               AY_T2CL             := $9808
000000r 2               AY_T2CH             := $9809
000000r 2               AY_SR               := $980A
000000r 2               AY_ACR              := $980B
000000r 2               AY_PCR              := $980C
000000r 2               AY_IFR              := $980D
000000r 2               AY_IER              := $980E
000000r 2               AY_ORA              := $980F
000000r 2               AY_BC1H             := %11100000         ; PCR CA2
000000r 2               AY_BC1L             := %11000000         ; PCR CA2
000000r 2               AY_BDIRH            := %00001110         ; PCR CB2
000000r 2               AY_BDIRL            := %00001100         ; PCR CB2
000000r 2               
000000r 2               ; Video Card / VGA Card (TMS9918/pico9918) | IO 8 | $9C00-$9C01
000000r 2               VC_DATA             := $9C00             ; R/W
000000r 2               VC_REG              := $9C01             ; Write
000000r 2               VC_STATUS           := $9C01             ; Read
000000r 2               
000000r 2               ; VERA | IO 8 | $9C00-$9C0F
000000r 2               VERA_ADDR_LOW       := $9C00
000000r 2               VERA_ADDR_MID       := $9C01
000000r 2               VERA_ADDR_HIGH      := $9C02
000000r 2               VERA_DATA0          := $9C03
000000r 2               VERA_DATA1          := $9C04
000000r 2               VERA_CTRL           := $9C05
000000r 2               VERA_DC_VIDEO       := $9C09
000000r 2               VERA_DC_HSCALE      := $9C0A
000000r 2               VERA_DC_VSCALE      := $9C0B
000000r 2               VERA_DC_BORDER      := $9C0B
000000r 2               VERA_L0_CONFIG      := $9C0D
000000r 2               VERA_L0_MAPBASE     := $9C0E
000000r 2               VERA_L0_TILEBASE    := $9C0F
000000r 2               
000000r 2               ; LCD Card | IO 8 | $9C00-$9C0F
000000r 2               LCD_PORTB           := $9C00
000000r 2               LCD_PORTA           := $9C01
000000r 2               LCD_DDRB            := $9C02
000000r 2               LCD_DDRA            := $9C03
000000r 2               LCD_T1CL            := $9C04
000000r 2               LCD_T1CH            := $9C05
000000r 2               LCD_T1LL            := $9C06
000000r 2               LCD_T1LH            := $9C07
000000r 2               LCD_T2CL            := $9C08
000000r 2               LCD_T2CH            := $9C09
000000r 2               LCD_SR              := $9C0A
000000r 2               LCD_ACR             := $9C0B
000000r 2               LCD_PCR             := $9C0C
000000r 2               LCD_IFR             := $9C0D
000000r 2               LCD_IER             := $9C0E
000000r 2               LCD_ORA             := $9C0F
000000r 2               LCD_E               := %10000000
000000r 2               LCD_RW              := %01000000
000000r 2               LCD_RS              := %00100000
000000r 2               
000000r 1               
000000r 1               .segment "KERNAL"
000000r 1               .include "Kernal.asm"
000000r 2               ; ***             ***
000000r 2               ; ***   KERNAL    ***
000000r 2               ; ***             ***
000000r 2               
000000r 2               ; Main entry point
000000r 2               RESET:
000000r 2  D8             cld                           ; Clear decimal mode
000001r 2  78             sei                           ; Disable interrupts
000002r 2               
000002r 2  A2 FF          ldx #$ff
000004r 2  9A             txs                           ; Reset the stack pointer
000005r 2               
000005r 2  A9 rr          lda #<IRQ                     ; Initialize the IRQ pointer
000007r 2  8D 14 03       sta IRQ_PTR
00000Ar 2  A9 rr          lda #>IRQ
00000Cr 2  8D 15 03       sta IRQ_PTR + 1
00000Fr 2               
00000Fr 2  A9 rr          lda #<NMI                     ; Initialize the NMI pointer
000011r 2  8D 18 03       sta NMI_PTR
000014r 2  A9 rr          lda #>NMI
000016r 2  8D 19 03       sta NMI_PTR + 1
000019r 2               
000019r 2  20 rr rr       jsr INIT_BUFFER               ; Initialize the input buffer
00001Cr 2  20 rr rr       jsr INIT_SC                   ; Initialize the serial output
00001Fr 2               
00001Fr 2  58             cli                           ; Enable interrupts
000020r 2               
000020r 2  4C rr rr       jmp WOZ_MON                   ; Jump to Wozmon
000023r 2               
000023r 2               ; Initialize the serial output
000023r 2               ; Modifies: Flags, A
000023r 2               INIT_SC:
000023r 2  A9 80          lda #%10000000                ; Interupts enabled, USB Serial, 115200 baud.
000025r 2  8D 01 84       sta EMU_SER_CTRL
000028r 2  60             rts
000029r 2               
000029r 2               ; Initialize the INPUT_BUFFER
000029r 2               ; Modifies: Flags, A
000029r 2               INIT_BUFFER:
000029r 2  A9 00          lda #$00
00002Br 2  85 00          sta READ_PTR                  ; Init read and write pointers
00002Dr 2  85 01          sta WRITE_PTR
00002Fr 2  60             rts
000030r 2               
000030r 2               ; Write a character from the A register to the INPUT_BUFFER
000030r 2               ; Modifies: Flags, X
000030r 2               WRITE_BUFFER:
000030r 2  A6 01          ldx WRITE_PTR
000032r 2  9D 00 02       sta INPUT_BUFFER,x
000035r 2  E6 01          inc WRITE_PTR
000037r 2  60             rts
000038r 2               
000038r 2               ; Read a character from the INPUT_BUFFER and store it in A register
000038r 2               ; Modifies: Flags, X, A
000038r 2               READ_BUFFER:
000038r 2  A6 00          ldx READ_PTR
00003Ar 2  BD 00 02       lda INPUT_BUFFER,x
00003Dr 2  E6 00          inc READ_PTR
00003Fr 2  60             rts
000040r 2               
000040r 2               ; Return in A register the number of unread bytes in the INPUT_BUFFER
000040r 2               ; Modifies: Flags, A
000040r 2               BUFFER_SIZE:
000040r 2  A5 01          lda WRITE_PTR
000042r 2  38             sec
000043r 2  E5 00          sbc READ_PTR
000045r 2  60             rts
000046r 2               
000046r 2               ; Get a character from the INPUT_BUFFER if available
000046r 2               ; On return, carry flag indicates whether a character was available
000046r 2               ; If character available the character will be in the A regsiter
000046r 2               ; Modifies: Flags, A
000046r 2               CHRIN:
000046r 2  DA             phx
000047r 2  20 rr rr       jsr BUFFER_SIZE               ; Check for character available
00004Ar 2  F0 09          beq @CHRIN_NO_CHAR            ; Branch if no character available
00004Cr 2  20 rr rr       jsr READ_BUFFER               ; Read the character from the buffer
00004Fr 2  20 rr rr       jsr CHROUT                    ; Echo
000052r 2  FA             plx
000053r 2  38             sec
000054r 2  60             rts
000055r 2               @CHRIN_NO_CHAR:
000055r 2  FA             plx
000056r 2  18             clc
000057r 2  60             rts
000058r 2               
000058r 2               ; Output a character from the A register to the Serial Card
000058r 2               ; Modifies: Flags
000058r 2               CHROUT:
000058r 2  8D 00 84       sta EMU_SER_DATA
00005Br 2  60             rts
00005Cr 2               
00005Cr 2               ; NMI Handler
00005Cr 2               NMI:
00005Cr 2  40             rti
00005Dr 2               
00005Dr 2               ; IRQ Handler
00005Dr 2               IRQ:
00005Dr 2  48             pha
00005Er 2  DA             phx
00005Fr 2  AD 01 84       lda EMU_SER_STATUS
000062r 2  29 80          and #%10000000                ; Check if serial data caused the interrupt
000064r 2  F0 06          beq @IRQ_EXIT                 ; If not, exit
000066r 2  AD 00 84       lda EMU_SER_DATA              ; Read the data from serial register
000069r 2  20 rr rr       jsr WRITE_BUFFER              ; Store to the input buffer
00006Cr 2               @IRQ_EXIT:
00006Cr 2  FA             plx
00006Dr 2  68             pla
00006Er 2  40             rti
00006Fr 2               
00006Fr 2               ; NMI Vector
00006Fr 2               NMI_VEC:
00006Fr 2  6C 18 03       jmp (NMI_PTR)                 ; Indirect jump through NMI pointer to the NMI handler
000072r 2               
000072r 2               ; Reset Vector
000072r 2               RESET_VEC:
000072r 2  4C rr rr       jmp RESET                     ; Initialize the system
000075r 2               
000075r 2               ; IRQ Vector
000075r 2               IRQ_VEC:
000075r 2  6C 14 03       jmp (IRQ_PTR)                 ; Indirect jump through IRQ pointer to the IRQ handler
000078r 2               
000078r 1               .segment "CART"
000000r 1               .include "Cart.asm"
000000r 2               ; ***             ***
000000r 2               ; ***    CART     ***
000000r 2               ; ***             ***
000000r 2               
000000r 1               .segment "WOZMON"
000000r 1               .include "Wozmon.asm"
000000r 2               ; ***             ***
000000r 2               ; ***   WOZMON    ***
000000r 2               ; ***             ***
000000r 2               
000000r 2               WOZ_XAML  = $24               ; Last "opened" location Low
000000r 2               WOZ_XAMH  = $25               ; Last "opened" location High
000000r 2               WOZ_STL   = $26               ; Store address Low
000000r 2               WOZ_STH   = $27               ; Store address High
000000r 2               WOZ_L     = $28               ; Hex value parsing Low
000000r 2               WOZ_H     = $29               ; Hex value parsing High
000000r 2               WOZ_YSAV  = $2A               ; Used to see if hex value is given
000000r 2               WOZ_MODE  = $2B               ; $00=XAM, $7F=STOR, $AE=BLOCK XAM
000000r 2               
000000r 2               WOZ_MON:
000000r 2  A9 1B          lda     #$1B                ; Begin with escape
000002r 2               
000002r 2               WOZ_NOTCR:
000002r 2  C9 08          cmp     #$08                ; Backspace key?
000004r 2  F0 18          beq     WOZ_BACKSPACE       ; Yes
000006r 2  C9 1B          cmp     #$1B                ; ESC?
000008r 2  F0 03          beq     WOZ_ESCAPE          ; Yes
00000Ar 2  C8             iny                         ; Advance text index
00000Br 2  10 14          bpl     WOZ_NEXTCHAR        ; Auto ESC if line longer than 127
00000Dr 2               
00000Dr 2               WOZ_ESCAPE:
00000Dr 2  A9 5C          lda     #$5C                ; "\"
00000Fr 2  20 rr rr       jsr     WOZ_ECHO            ; Output it
000012r 2               
000012r 2               WOZ_GETLINE:
000012r 2  A9 0D          lda     #$0D                ; Send CR
000014r 2  20 rr rr       jsr     WOZ_ECHO
000017r 2  A9 0A          lda     #$0A                ; Send LF
000019r 2  20 rr rr       jsr     WOZ_ECHO
00001Cr 2               
00001Cr 2  A0 01          ldy     #$01                ; Initialize text index
00001Er 2               WOZ_BACKSPACE:
00001Er 2  88             dey                         ; Back up text index
00001Fr 2  30 F1          bmi     WOZ_GETLINE         ; Beyond start of line, reinitialize
000021r 2               
000021r 2               WOZ_NEXTCHAR:
000021r 2  20 rr rr       jsr     CHRIN               ; Get next character
000024r 2  90 FB          bcc     WOZ_NEXTCHAR        ; No character found
000026r 2  99 00 02       sta     INPUT_BUFFER,y      ; Add to text buffer
000029r 2  C9 0D          cmp     #$0D                ; CR?
00002Br 2  D0 D5          bne     WOZ_NOTCR           ; No
00002Dr 2               
00002Dr 2  A0 FF          ldy     #$FF                ; Reset text index
00002Fr 2  A9 00          lda     #$00                ; For XAM mode
000031r 2  AA             tax                         ; X=0
000032r 2               WOZ_SETBLOCK:
000032r 2  0A             asl
000033r 2               WOZ_SETSTOR:
000033r 2  0A             asl                         ; Leaves $7B if setting STOR mode
000034r 2  85 2B          sta     WOZ_MODE            ; $00 = XAM, $74 = STOR, $B8 = BLOK XAM
000036r 2               WOZ_BLSKIP:
000036r 2  C8             iny                         ; Advance text index
000037r 2               WOZ_NEXTITEM:
000037r 2  B9 00 02       lda     INPUT_BUFFER,y      ; Get character
00003Ar 2  C9 0D          cmp     #$0D                ; CR?
00003Cr 2  F0 D4          beq     WOZ_GETLINE         ; Yes, done this line
00003Er 2  C9 2E          cmp     #$2E                ; "."?
000040r 2  90 F4          bcc     WOZ_BLSKIP          ; Skip delimiter
000042r 2  F0 EE          beq     WOZ_SETBLOCK        ; Set BLOCK XAM mode
000044r 2  C9 3A          cmp     #$3A                ; ":"?
000046r 2  F0 EB          beq     WOZ_SETSTOR         ; Yes, set STOR mode
000048r 2  C9 52          cmp     #$52                ; "R"?
00004Ar 2  F0 3B          beq     WOZ_RUN             ; Yes, run user program
00004Cr 2  86 28          stx     WOZ_L               ; $00 -> L
00004Er 2  86 29          stx     WOZ_H               ;    and H
000050r 2  84 2A          sty     WOZ_YSAV            ; Save Y for comparison
000052r 2               
000052r 2               WOZ_NEXTHEX:
000052r 2  B9 00 02       lda     INPUT_BUFFER,y      ; Get character for hex test
000055r 2  49 30          eor     #$30                ; Map digits to $0-9
000057r 2  C9 0A          cmp     #$0A                ; Digit?
000059r 2  90 06          bcc     WOZ_DIG             ; Yes
00005Br 2  69 88          adc     #$88                ; Map letter "A"-"F" to $FA-FF
00005Dr 2  C9 FA          cmp     #$FA                ; Hex letter?
00005Fr 2  90 11          bcc     WOZ_NOTHEX          ; No, character not hex
000061r 2               WOZ_DIG:
000061r 2  0A             asl
000062r 2  0A             asl                         ; Hex digit to MSD of A
000063r 2  0A             asl
000064r 2  0A             asl
000065r 2               
000065r 2  A2 04          ldx     #$04                ; Shift count
000067r 2               WOZ_HEXSHIFT:
000067r 2  0A             asl                         ; Hex digit left, MSB to carry
000068r 2  26 28          rol     WOZ_L               ; Rotate into LSD
00006Ar 2  26 29          rol     WOZ_H               ; Rotate into MSD's
00006Cr 2  CA             dex                         ; Done 4 shifts?
00006Dr 2  D0 F8          bne     WOZ_HEXSHIFT        ; No, loop
00006Fr 2  C8             iny                         ; Advance text index
000070r 2  D0 E0          bne     WOZ_NEXTHEX         ; Always taken. Check next character for hex
000072r 2               
000072r 2               WOZ_NOTHEX:
000072r 2  C4 2A          cpy     WOZ_YSAV            ; Check if L, H empty (no hex digits)
000074r 2  F0 97          beq     WOZ_ESCAPE          ; Yes, generate ESC sequence
000076r 2               
000076r 2  24 2B          bit     WOZ_MODE            ; Test MODE byte
000078r 2  50 16          bvc     WOZ_NOTSTOR         ; B6=0 is STOR, 1 is XAM and BLOCK XAM
00007Ar 2               
00007Ar 2  A5 28          lda     WOZ_L               ; LSD's of hex data
00007Cr 2  81 26          sta     (WOZ_STL,x)         ; Store current 'store index'
00007Er 2  E6 26          inc     WOZ_STL             ; Increment store index
000080r 2  D0 B5          bne     WOZ_NEXTITEM        ; Get next item (no carry)
000082r 2  E6 27          inc     WOZ_STH             ; Add carry to 'store index' high order
000084r 2               WOZ_TONEXTITEM:
000084r 2  4C rr rr       jmp     WOZ_NEXTITEM        ; Get next command item
000087r 2               
000087r 2               WOZ_RUN:
000087r 2  20 rr rr       jsr     WOZ_JUMP            ; Begin executing at XAM index
00008Ar 2  4C rr rr       jmp     WOZ_MON             ; After returning we reset
00008Dr 2               WOZ_JUMP:
00008Dr 2  6C 24 00       jmp     (WOZ_XAML)          ; Run at current XAM index
000090r 2               
000090r 2               WOZ_NOTSTOR:
000090r 2  30 30          bmi     WOZ_XAMNEXT         ; B7 = 0 for XAM, 1 for BLOCK XAM
000092r 2               
000092r 2  A2 02          ldx     #$02                ; Byte count
000094r 2               WOZ_SETADR:
000094r 2  B5 27          lda     WOZ_L-1,x           ; Copy hex data to
000096r 2  95 25          sta     WOZ_STL-1,x         ;  'store index'
000098r 2  95 23          sta     WOZ_XAML-1,x        ; And to 'XAM index'
00009Ar 2  CA             dex                         ; Next of 2 bytes
00009Br 2  D0 F7          bne     WOZ_SETADR          ; Loop unless X = 0
00009Dr 2               
00009Dr 2               WOZ_NXTPRNT:
00009Dr 2  D0 19          bne     WOZ_PRDATA          ; NE means no address to print
00009Fr 2  A9 0D          lda     #$0D                ; CR
0000A1r 2  20 rr rr       jsr     WOZ_ECHO            ; Output it
0000A4r 2  A9 0A          lda     #$0A                ; LF
0000A6r 2  20 rr rr       jsr     WOZ_ECHO            ; Output it
0000A9r 2  A5 25          lda     WOZ_XAMH            ; 'Examine index' high-order byte
0000ABr 2  20 rr rr       jsr     WOZ_PRBYTE          ; Output it in hex format
0000AEr 2  A5 24          lda     WOZ_XAML            ; Low-order 'examine index' byte
0000B0r 2  20 rr rr       jsr     WOZ_PRBYTE          ; Output it in hex format
0000B3r 2  A9 3A          lda     #$3A                ; ":"
0000B5r 2  20 rr rr       jsr     WOZ_ECHO            ; Output it
0000B8r 2               
0000B8r 2               WOZ_PRDATA:
0000B8r 2  A9 20          lda     #$20                ; Blank
0000BAr 2  20 rr rr       jsr     WOZ_ECHO            ; Output it
0000BDr 2  A1 24          lda     (WOZ_XAML,x)        ; Get data byte at 'examine index'
0000BFr 2  20 rr rr       jsr     WOZ_PRBYTE          ; Output it in hex format
0000C2r 2               WOZ_XAMNEXT:
0000C2r 2  86 2B          stx     WOZ_MODE            ; 0 -> MODE (XAM mode)
0000C4r 2  A5 24          lda     WOZ_XAML
0000C6r 2  C5 28          cmp     WOZ_L               ; Compare 'examine index' to hex data
0000C8r 2  A5 25          lda     WOZ_XAMH
0000CAr 2  E5 29          sbc     WOZ_H
0000CCr 2  B0 B6          bcs     WOZ_TONEXTITEM      ; Not less, so no more data to output
0000CEr 2               
0000CEr 2  E6 24          inc     WOZ_XAML
0000D0r 2  D0 02          bne     WOZ_MOD8CHK         ; Increment 'examine index'
0000D2r 2  E6 25          inc     WOZ_XAMH
0000D4r 2               
0000D4r 2               WOZ_MOD8CHK:
0000D4r 2  A5 24          lda     WOZ_XAML            ; Check low-order 'examine index' byte
0000D6r 2  29 07          and     #$07                ; For MOD 8 = 0
0000D8r 2  10 C3          bpl     WOZ_NXTPRNT         ; Always taken
0000DAr 2               
0000DAr 2               WOZ_PRBYTE:
0000DAr 2  48             pha                         ; Save A for LSD
0000DBr 2  4A             lsr
0000DCr 2  4A             lsr
0000DDr 2  4A             lsr                         ; MSD to LSD position
0000DEr 2  4A             lsr
0000DFr 2  20 rr rr       jsr     WOZ_PRHEX           ; Output hex digit
0000E2r 2  68             pla                         ; Restore A
0000E3r 2               
0000E3r 2               WOZ_PRHEX:
0000E3r 2  29 0F          and     #$0F                ; Mask LSD for hex print
0000E5r 2  09 30          ora     #$30                ; Add "0"
0000E7r 2  C9 3A          cmp     #$3A                ; Digit?
0000E9r 2  90 02          bcc     WOZ_ECHO            ; Yes, output it
0000EBr 2  69 06          adc     #$06                ; Add offset for letter
0000EDr 2               
0000EDr 2               WOZ_ECHO:
0000EDr 2  20 rr rr       jsr CHROUT                  ; Output the character
0000F0r 2  60             rts                         ; Return
0000F1r 2               
0000F1r 1               .segment "VECTORS"
000000r 1               .include "Vectors.asm"
000000r 2               ; ***             ***
000000r 2               ; ***   VECTORS   ***
000000r 2               ; ***             ***
000000r 2               
000000r 2  rr rr        .word   NMI_VEC           ; NMI vector
000002r 2  rr rr        .word   RESET_VEC         ; RESET vector
000004r 2  rr rr        .word   IRQ_VEC           ; IRQ vector
000006r 2               
000006r 1               
