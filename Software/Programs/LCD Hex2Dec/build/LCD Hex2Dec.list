ca65 V2.18 - N/A
Main file   : ./src/LCD Hex2Dec.asm
Current file: ./src/LCD Hex2Dec.asm

000000r 1               .setcpu "65C02"
000000r 1               
000000r 1               .include "../../../6502.inc"
000000r 2               ; ***                     ***
000000r 2               ; ***   6502 INCLUDES     ***
000000r 2               ; ***                     ***
000000r 2               
000000r 2               ; Zero Page
000000r 2               ZP                  := $00
000000r 2               READ_PTR            := $00
000000r 2               WRITE_PTR           := $01
000000r 2               
000000r 2               ; Stack
000000r 2               STACK               := $0100             ; $0100-$01FF
000000r 2               
000000r 2               ; Input Buffer
000000r 2               INPUT_BUFFER        := $0200             ; $0200-$02FF
000000r 2               
000000r 2               ; Kernal Vars
000000r 2               KERNAL_VARS         := $0300             ; $0300-$03FF
000000r 2               
000000r 2               IRQ_PTR             := $0314             ; $0314-$0315
000000r 2               BRK_PTR             := $0316             ; $0316-$0317
000000r 2               NMI_PTR             := $0318             ; $0318-$0319
000000r 2               
000000r 2               ; User Vars
000000r 2               USER_VARS           := $0400             ; $0400-$07FF
000000r 2               
000000r 2               ; Program
000000r 2               PROGRAM             := $0800             ; $0800-$7FFF
000000r 2               
000000r 2               ; RAM Card | IO 1 & 2 | $8000-$87FF
000000r 2               RAM_DATA            := $8000             ; R/W ($8000-$83FE)
000000r 2               RAM_DATA_L          := $8000             ; R/W ($8000-$83FE)
000000r 2               RAM_DATA_H          := $8400             ; R/W ($8400-$87FE)
000000r 2               RAM_BANK            := $83FF             ; All three RAM_BANK addresses address the same bank switching
000000r 2               RAM_BANK_L          := $83FF             ; latch and can be univerally interchanged
000000r 2               RAM_BANK_H          := $87FF             ; RAM bank latch value ($00-$FF) sets which of 256 ~1K banks of RAM is selected in both H or L
000000r 2               
000000r 2               ; Emulator | IO 2 | $8400-$840F
000000r 2               EMU_SER_DATA        := $8400             ; R/W
000000r 2               EMU_SER_CTRL        := $8401             ; Write
000000r 2               EMU_SER_STATUS      := $8401             ; Read
000000r 2               EMU_KB_CMD          := $8402             ; Write
000000r 2               EMU_KB_DATA         := $8402             ; Read
000000r 2               EMU_MOUSE_X         := $8403             ; Read
000000r 2               EMU_MOUSE_Y         := $8404             ; Read
000000r 2               EMU_MOUSE_W         := $8405             ; Read
000000r 2               EMU_MOUSE_BTNS      := $8406             ; Read
000000r 2               EMU_JOY_BTNS        := $8407             ; Read
000000r 2               EMU_RTC_SEC         := $8408             ; Read
000000r 2               EMU_RTC_MIN         := $8409             ; Read
000000r 2               EMU_RTC_HR          := $840A             ; Read
000000r 2               EMU_RTC_DAY         := $840B             ; Read
000000r 2               EMU_RTC_MON         := $840C             ; Read
000000r 2               EMU_RTC_YR          := $840D             ; Read
000000r 2               EMU_PRAM_DATA       := $840E             ; R/W
000000r 2               EMU_PRAM_ADDR       := $840F             ; R/W
000000r 2               EMU_RAM             := $8600             ; R/W
000000r 2               EMU_RAM_BANK        := $87FF             ; Write
000000r 2               
000000r 2               ; RTC Card | IO 3 | $8800-$881F
000000r 2               RTC_SEC             := $8800
000000r 2               RTC_MIN             := $8801
000000r 2               RTC_HR              := $8802
000000r 2               RTC_DAY             := $8803
000000r 2               RTC_DATE            := $8804
000000r 2               RTC_MON             := $8805
000000r 2               RTC_YR              := $8806
000000r 2               RTC_CENT            := $8807
000000r 2               RTC_ALARM_SEC       := $8808
000000r 2               RTC_ALARM_MIN       := $8809
000000r 2               RTC_ALARM_HR        := $880A
000000r 2               RTC_ALARM_DATE      := $880B
000000r 2               RTC_WD_L            := $880C
000000r 2               RTC_WD_H            := $880D
000000r 2               RTC_CTRL_A          := $880E
000000r 2               RTC_CTRL_B          := $880F
000000r 2               RTC_RAM_ADDR        := $8810
000000r 2               RTC_RAM_DATA        := $8813
000000r 2               
000000r 2               ; Storage Card | IO 4 | $8C00-$8C07
000000r 2               ST_DATA             := $8C00             ; R/W
000000r 2               ST_ERROR            := $8C01             ; Read
000000r 2               ST_FEATURE          := $8C01             ; Write
000000r 2               ST_SECT_CNT         := $8C02             ; R/W
000000r 2               ST_LBA_0            := $8C03             ; R/W
000000r 2               ST_LBA_1            := $8C04             ; R/W
000000r 2               ST_LBA_2            := $8C05             ; R/W
000000r 2               ST_LBA_3            := $8C06             ; R/W
000000r 2               ST_STATUS           := $8C07             ; Read
000000r 2               ST_CMD              := $8C07             ; Write
000000r 2               ST_ERR_AMNF         := %00000001
000000r 2               ST_ERR_ABRT         := %00000100
000000r 2               ST_ERR_IDNF         := %00010000
000000r 2               ST_ERR_UNC          := %01000000
000000r 2               ST_ERR_BBK          := %10000000
000000r 2               ST_STATUS_ERR       := %00000001
000000r 2               ST_STATUS_IDX       := %00000010
000000r 2               ST_STATUS_CORR      := %00000100
000000r 2               ST_STATUS_DRQ       := %00001000
000000r 2               ST_STATUS_DSC       := %00010000
000000r 2               ST_STATUS_DWF       := %00100000
000000r 2               ST_STATUS_RDY       := %01000000
000000r 2               ST_STATUS_BSY       := %10000000
000000r 2               
000000r 2               ; Serial Card | IO 5 | $9000-$9003
000000r 2               SC_DATA             := $9000             ; R/W
000000r 2               SC_RESET            := $9001             ; Write
000000r 2               SC_STATUS           := $9001             ; Read
000000r 2               SC_CMD              := $9002             ; R/W
000000r 2               SC_CTRL             := $9003             ; R/W
000000r 2               
000000r 2               ; GPIO Card / Input Board | IO 6 | $9400-$940F
000000r 2               GPIO_PORTB          := $9400
000000r 2               GPIO_PORTA          := $9401
000000r 2               GPIO_DDRB           := $9402
000000r 2               GPIO_DDRA           := $9403
000000r 2               GPIO_T1CL           := $9404
000000r 2               GPIO_T1CH           := $9405
000000r 2               GPIO_T1LL           := $9406
000000r 2               GPIO_T1LH           := $9407
000000r 2               GPIO_T2CL           := $9408
000000r 2               GPIO_T2CH           := $9409
000000r 2               GPIO_SR             := $940A
000000r 2               GPIO_ACR            := $940B
000000r 2               GPIO_PCR            := $940C
000000r 2               GPIO_IFR            := $940D
000000r 2               GPIO_IER            := $940E
000000r 2               GPIO_ORA            := $940F
000000r 2               
000000r 2               ; Sound Card (SID/ARMSID) | IO 7 | $9800-$980F
000000r 2               
000000r 2               
000000r 2               ; Sound Card (AY-3-8912) | IO 7 | $9800-$980F
000000r 2               AY_PORTB            := $9800
000000r 2               AY_PORTA            := $9801
000000r 2               AY_DDRB             := $9802
000000r 2               AY_DDRA             := $9803
000000r 2               AY_T1CL             := $9804
000000r 2               AY_T1CH             := $9805
000000r 2               AY_T1LL             := $9806
000000r 2               AY_T1LH             := $9807
000000r 2               AY_T2CL             := $9808
000000r 2               AY_T2CH             := $9809
000000r 2               AY_SR               := $980A
000000r 2               AY_ACR              := $980B
000000r 2               AY_PCR              := $980C
000000r 2               AY_IFR              := $980D
000000r 2               AY_IER              := $980E
000000r 2               AY_ORA              := $980F
000000r 2               AY_BC1H             := %11100000         ; PCR CA2
000000r 2               AY_BC1L             := %11000000         ; PCR CA2
000000r 2               AY_BDIRH            := %00001110         ; PCR CB2
000000r 2               AY_BDIRL            := %00001100         ; PCR CB2
000000r 2               
000000r 2               ; Video Card / VGA Card (TMS9918/pico9918) | IO 8 | $9C00-$9C01
000000r 2               VC_DATA             := $9C00             ; R/W
000000r 2               VC_REG              := $9C01             ; Write
000000r 2               VC_STATUS           := $9C01             ; Read
000000r 2               
000000r 2               ; VERA | IO 8 | $9C00-$9C0F
000000r 2               VERA_ADDR_LOW       := $9C00
000000r 2               VERA_ADDR_MID       := $9C01
000000r 2               VERA_ADDR_HIGH      := $9C02
000000r 2               VERA_DATA0          := $9C03
000000r 2               VERA_DATA1          := $9C04
000000r 2               VERA_CTRL           := $9C05
000000r 2               VERA_DC_VIDEO       := $9C09
000000r 2               VERA_DC_HSCALE      := $9C0A
000000r 2               VERA_DC_VSCALE      := $9C0B
000000r 2               VERA_DC_BORDER      := $9C0B
000000r 2               VERA_L0_CONFIG      := $9C0D
000000r 2               VERA_L0_MAPBASE     := $9C0E
000000r 2               VERA_L0_TILEBASE    := $9C0F
000000r 2               
000000r 2               ; LCD Card | IO 8 | $9C00-$9C0F
000000r 2               LCD_PORTB           := $9C00
000000r 2               LCD_PORTA           := $9C01
000000r 2               LCD_DDRB            := $9C02
000000r 2               LCD_DDRA            := $9C03
000000r 2               LCD_T1CL            := $9C04
000000r 2               LCD_T1CH            := $9C05
000000r 2               LCD_T1LL            := $9C06
000000r 2               LCD_T1LH            := $9C07
000000r 2               LCD_T2CL            := $9C08
000000r 2               LCD_T2CH            := $9C09
000000r 2               LCD_SR              := $9C0A
000000r 2               LCD_ACR             := $9C0B
000000r 2               LCD_PCR             := $9C0C
000000r 2               LCD_IFR             := $9C0D
000000r 2               LCD_IER             := $9C0E
000000r 2               LCD_ORA             := $9C0F
000000r 2               LCD_E               := %10000000
000000r 2               LCD_RW              := %01000000
000000r 2               LCD_RS              := %00100000
000000r 2               
000000r 1               
000000r 1               .segment "CODE"
000000r 1               
000000r 1               VALUE       := $00
000000r 1               MOD10       := $02
000000r 1               RESULT      := $04
000000r 1               
000000r 1               reset:
000000r 1  A2 FF          ldx #$ff
000002r 1  9A             txs
000003r 1               
000003r 1  A9 FF          lda #%11111111 ; Set all pins on port B to output
000005r 1  8D 02 9C       sta LCD_DDRB
000008r 1  A9 E0          lda #%11100000 ; Set top 3 pins on port A to output
00000Ar 1  8D 03 9C       sta LCD_DDRA
00000Dr 1               
00000Dr 1  A9 38          lda #%00111000 ; Set 8-bit mode; 2-line display; 5x8 font
00000Fr 1  20 rr rr       jsr lcd_instruction
000012r 1  A9 0E          lda #%00001110 ; Display on; cursor on; blink off
000014r 1  20 rr rr       jsr lcd_instruction
000017r 1  A9 06          lda #%00000110 ; Increment and shift cursor; don't shift display
000019r 1  20 rr rr       jsr lcd_instruction
00001Cr 1               
00001Cr 1               clear:
00001Cr 1  A9 01          lda #$00000001 ; Clear display
00001Er 1  20 rr rr       jsr lcd_instruction
000021r 1               
000021r 1               main:
000021r 1  A9 00          lda #0
000023r 1  85 04          sta RESULT        ; Intialize the result
000025r 1               
000025r 1  AD rr rr       lda number        ; Initialize the number
000028r 1  85 00          sta VALUE
00002Ar 1  AD rr rr       lda number + 1
00002Dr 1  85 01          sta VALUE + 1
00002Fr 1               
00002Fr 1               divide:
00002Fr 1  A9 00          lda #0            ; Initialize the remainder to zero
000031r 1  85 02          sta MOD10
000033r 1  85 03          sta MOD10 + 1
000035r 1  18             clc
000036r 1               
000036r 1  A2 10          ldx #16
000038r 1               loop:
000038r 1  26 00          rol VALUE         ; Rotate quotient and remainder
00003Ar 1  26 01          rol VALUE + 1
00003Cr 1  26 02          rol MOD10
00003Er 1  26 03          rol MOD10 + 1
000040r 1               
000040r 1  38             sec               ; A,Y = dividend - divisor
000041r 1  A5 02          lda MOD10
000043r 1  E9 0A          sbc #10
000045r 1  A8             tay               ; Save low byte in Y
000046r 1  A5 03          lda MOD10 + 1
000048r 1  E9 00          sbc #0
00004Ar 1  90 04          bcc ignore_result ; Branch if dividend < divisor
00004Cr 1  84 02          sty MOD10
00004Er 1  85 03          sta MOD10 + 1
000050r 1               
000050r 1               ignore_result:
000050r 1  CA             dex
000051r 1  D0 E5          bne loop
000053r 1  26 00          rol VALUE
000055r 1  26 01          rol VALUE + 1
000057r 1               
000057r 1  A5 02          lda MOD10
000059r 1  18             clc
00005Ar 1  69 30          adc #48           ; ASCII "0"
00005Cr 1  20 rr rr       jsr push_char
00005Fr 1               
00005Fr 1  A5 00          lda VALUE         ; If value != 0, then continue dividing
000061r 1  05 01          ora VALUE + 1
000063r 1  D0 CA          bne divide        ; Branch if value != 0
000065r 1               
000065r 1  A2 00          ldx #0
000067r 1               print:
000067r 1  B5 04          lda RESULT,x
000069r 1  F0 07          beq halt
00006Br 1  20 rr rr       jsr print_char
00006Er 1  E8             inx
00006Fr 1  4C rr rr       jmp print
000072r 1               
000072r 1               halt:
000072r 1  4C rr rr       jmp halt
000075r 1               
000075r 1  C1 06        number: .word 1729
000077r 1               
000077r 1               push_char:
000077r 1  48             pha               ; Push new first char onto stack
000078r 1  A0 00          ldy #0
00007Ar 1               char_loop:
00007Ar 1  B9 04 00       lda RESULT,y      ; Get char on string and put in X
00007Dr 1  AA             tax
00007Er 1  68             pla
00007Fr 1  99 04 00       sta RESULT,y      ; Pull char off stack and add it to the string
000082r 1  C8             iny
000083r 1  8A             txa
000084r 1  48             pha               ; Push char from string onto stack
000085r 1  D0 F3          bne char_loop
000087r 1  68             pla
000088r 1  99 04 00       sta RESULT,y      ; Pull the null off the stack and add to the end of the string
00008Br 1  60             rts
00008Cr 1               
00008Cr 1               lcd_wait:
00008Cr 1  48             pha
00008Dr 1  A9 00          lda #%00000000  ; Port B is input
00008Fr 1  8D 02 9C       sta LCD_DDRB
000092r 1               lcd_busy:
000092r 1  A9 40          lda #LCD_RW
000094r 1  8D 01 9C       sta LCD_PORTA
000097r 1  A9 C0          lda #(LCD_RW | LCD_E)
000099r 1  8D 01 9C       sta LCD_PORTA
00009Cr 1  AD 00 9C       lda LCD_PORTB
00009Fr 1  29 80          and #%10000000
0000A1r 1  D0 EF          bne lcd_busy
0000A3r 1               
0000A3r 1  A9 40          lda #LCD_RW
0000A5r 1  8D 01 9C       sta LCD_PORTA
0000A8r 1  A9 FF          lda #%11111111  ; Port B is output
0000AAr 1  8D 02 9C       sta LCD_DDRB
0000ADr 1  68             pla
0000AEr 1  60             rts
0000AFr 1               
0000AFr 1               lcd_instruction:
0000AFr 1  20 rr rr       jsr lcd_wait
0000B2r 1  8D 00 9C       sta LCD_PORTB
0000B5r 1  A9 00          lda #0         ; Clear RS/RW/E bits
0000B7r 1  8D 01 9C       sta LCD_PORTA
0000BAr 1  A9 80          lda #LCD_E         ; Set E bit to send instruction
0000BCr 1  8D 01 9C       sta LCD_PORTA
0000BFr 1  A9 00          lda #0         ; Clear RS/RW/E bits
0000C1r 1  8D 01 9C       sta LCD_PORTA
0000C4r 1  60             rts
0000C5r 1               
0000C5r 1               print_char:
0000C5r 1  20 rr rr       jsr lcd_wait
0000C8r 1  8D 00 9C       sta LCD_PORTB
0000CBr 1  A9 20          lda #LCD_RS         ; Set RS; Clear RW/E bits
0000CDr 1  8D 01 9C       sta LCD_PORTA
0000D0r 1  A9 A0          lda #(LCD_RS | LCD_E)   ; Set E bit to send instruction
0000D2r 1  8D 01 9C       sta LCD_PORTA
0000D5r 1  A9 20          lda #LCD_RS         ; Clear E bits
0000D7r 1  8D 01 9C       sta LCD_PORTA
0000DAr 1  60             rts
0000DAr 1               
